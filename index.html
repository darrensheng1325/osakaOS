<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>osakaOS - Web Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: #000;
            color: #0f0;
            font-family: monospace;
            overflow: hidden;
            position: fixed;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        h1 {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: 20px;
            color: #0f0;
            pointer-events: none;
        }
        
        #loading {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: 18px;
            color: #0f0;
            pointer-events: none;
        }
        
        #status {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: 14px;
            pointer-events: none;
        }
        
        #osaka-canvas {
            width: 100vw !important;
            height: 100vh !important;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #000;
            display: none; /* Hidden by default, shown when graphics mode is active */
            object-fit: cover; /* Fill entire screen, may crop edges */
            cursor: none; /* Hide cursor on graphics canvas */
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            z-index: 1;
        }
        
        #osaka-text-canvas {
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #000;
            display: block; /* Show text canvas by default */
            object-fit: contain;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1 id="title">osakaOS v2.1 - Web Edition</h1>
        <div id="loading">Loading osakaOS...</div>
        <div id="status" class="hidden"></div>
        <canvas id="osaka-canvas" width="320" height="200" tabindex="0"></canvas>
        <canvas id="osaka-text-canvas" width="640" height="400" tabindex="0"></canvas>
    </div>
    
    <!-- Fallback message if JS fails -->
    <noscript>
        <div style="color: #f00; text-align: center; padding: 20px;">
            JavaScript is required to run osakaOS. Please enable JavaScript in your browser.
        </div>
    </noscript>
    
    <script>
        // Test that JavaScript is running
        console.log('HTML loaded, initializing Module...');
        // Initialize EGA palette early, before module loads
        // This ensures the palette is available when rendering starts
        function initializeEGAPalette() {
            // Check if Module exists
            if (typeof Module === 'undefined') {
                console.log('[JS] Module not defined yet, skipping palette initialization');
                return;
            }
            
            if (!Module.ega_palette || Module.ega_palette.length === 0) {
                Module.ega_palette = [];
                
                // Initialize EGA palette - use the same calculation as the original VGA driver
                // VGA writes 6-bit values (0-63) to palette registers, which need to be scaled to 8-bit (0-255)
                // Scale factor: 255/63 â‰ˆ 4.048, but we use 4 for exact match with QEMU
                for (var i = 0; i < 256; i++) {
                    var r6 = 0, g6 = 0, b6 = 0; // 6-bit values (0-63)
                    var r = 0, g = 0, b = 0;     // 8-bit values (0-255)
                    switch (Math.floor(i / 64)) {
                        case 0:
                            r6 = (i & 0x20 ? 0x15 : 0) | (i & 0x04 ? 0x2a : 0);
                            g6 = (i & 0x10 ? 0x15 : 0) | (i & 0x02 ? 0x2a : 0);
                            b6 = (i & 0x08 ? 0x15 : 0) | (i & 0x01 ? 0x2a : 0);
                            // Scale 6-bit to 8-bit: multiply by 4
                            r = r6 * 4;
                            g = g6 * 4;
                            b = b6 * 4;
                            break;
                        case 1:
                            r6 = ((i & 0x20 ? 0x15 : 0) | (i & 0x04 ? 0x2a : 0)) >> 3;
                            g6 = ((i & 0x10 ? 0x15 : 0) | (i & 0x02 ? 0x2a : 0)) >> 3;
                            b6 = ((i & 0x08 ? 0x15 : 0) | (i & 0x01 ? 0x2a : 0)) >> 3;
                            r = r6 * 4;
                            g = g6 * 4;
                            b = b6 * 4;
                            break;
                        case 2:
                            r6 = ((i & 0x20 ? 0x15 : 0) | (i & 0x04 ? 0x2a : 0)) << 3;
                            g6 = ((i & 0x10 ? 0x15 : 0) | (i & 0x02 ? 0x2a : 0)) << 3;
                            b6 = ((i & 0x08 ? 0x15 : 0) | (i & 0x01 ? 0x2a : 0)) << 3;
                            // Clamp to 63 (6-bit max) before scaling
                            if (r6 > 63) r6 = 63;
                            if (g6 > 63) g6 = 63;
                            if (b6 > 63) b6 = 63;
                            r = r6 * 4;
                            g = g6 * 4;
                            b = b6 * 4;
                            break;
                        default:
                            r = g = b = 0;
                            break;
                    }
                    // Store palette in RGB format: [Red, Green, Blue]
                    Module.ega_palette[i] = [r, g, b];
                }
                
                // Debug: verify color 0 is black
                console.log('[JS] EGA palette initialized early. Color 0 (black):', Module.ega_palette[0]);
                if (Module.ega_palette[0][0] !== 0 || Module.ega_palette[0][1] !== 0 || Module.ega_palette[0][2] !== 0) {
                    console.error('[JS] ERROR: Color 0 is not black!', Module.ega_palette[0]);
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded');
        });
        
        // Error handling
        // Error handling
        window.addEventListener('error', function(e) {
            console.error('Global error:', e);
            var status = document.getElementById('status');
            if (status) {
                status.textContent = 'Error: ' + (e.message || 'Unknown error');
                status.classList.remove('hidden');
                status.style.color = '#f00';
            }
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e);
            var status = document.getElementById('status');
            if (status) {
                status.textContent = 'Error: ' + (e.reason || 'Unknown error');
                status.classList.remove('hidden');
                status.style.color = '#f00';
            }
        });
        
        // Define Module configuration before loading osakaOS.js
        var Module = {
            preRun: [],
            postRun: [],
            // Initialize EGA palette array
            ega_palette: [],
            onRuntimeInitialized: function() {
                console.log('[JS] Emscripten runtime initialized');
                
                // Focus the canvas so it can receive keyboard events
                var graphicsCanvas = document.getElementById('osaka-canvas');
                var textCanvas = document.getElementById('osaka-text-canvas');
                if (graphicsCanvas) {
                    graphicsCanvas.focus();
                } else if (textCanvas) {
                    textCanvas.focus();
                }
                
                // Re-attach iframe functions in case Emscripten overwrote Module
                if (typeof window.setupIframeAppFunction !== 'undefined') {
                    Module.setupIframeApp = window.setupIframeAppFunction;
                    console.log('[JS] Re-attached setupIframeApp');
                }
                if (typeof window.captureIframeToBufferFunction !== 'undefined') {
                    Module.captureIframeToBuffer = window.captureIframeToBufferFunction;
                    console.log('[JS] Re-attached captureIframeToBuffer');
                }
                if (typeof window.forwardKeyToIframeFunction !== 'undefined') {
                    Module.forwardKeyToIframe = window.forwardKeyToIframeFunction;
                    console.log('[JS] Re-attached forwardKeyToIframe');
                }
                if (typeof window.forwardMouseToIframeFunction !== 'undefined') {
                    Module.forwardMouseToIframe = window.forwardMouseToIframeFunction;
                    console.log('[JS] Re-attached forwardMouseToIframe');
                }
                
                // Ensure safeReadAndPrintString and renderPixels are still available
                // (Emscripten might have replaced the Module object)
                if (!Module.safeReadAndPrintString) {
                    console.error('[JS] safeReadAndPrintString missing after runtime init! Re-attaching...');
                    // Re-attach the function from the original Module definition
                    Module.safeReadAndPrintString = function(ptr) {
                        if (!ptr) return;
                        try {
                            var heapU8 = (typeof HEAPU8 !== 'undefined') ? HEAPU8 : window.HEAPU8;
                            if (!heapU8) {
                                console.error('[JS] HEAPU8 not available');
                                return;
                            }
                            var heapSize = heapU8.length;
                            if (ptr < 0 || ptr >= heapSize) return;
                            var str = '';
                            var maxLen = Math.min(256, heapSize - ptr);
                            for (var i = 0; i < maxLen; i++) {
                                if (ptr + i >= heapSize) break;
                                var ch = heapU8[ptr + i];
                                if (ch === 0) break;
                                str += String.fromCharCode(ch);
                            }
                            if (!Module._printf_x) Module._printf_x = 0;
                            if (!Module._printf_y) Module._printf_y = 0;
                            for (var i = 0; i < str.length; i++) {
                                var ch = str.charCodeAt(i);
                                if (ch === 10) {
                                    Module._printf_y++;
                                    Module._printf_x = 0;
                                    continue;
                                }
                                if (Module.putCharTUI) {
                                    Module.putCharTUI(Module._printf_x, Module._printf_y, ch, 0x07, 0x00);
                                }
                                Module._printf_x++;
                                if (Module._printf_x >= 80) {
                                    Module._printf_x = 0;
                                    Module._printf_y++;
                                }
                                if (Module._printf_y >= 25) {
                                    Module._printf_y = 24;
                                }
                            }
                        } catch (e) {
                            console.error('[JS] safeReadAndPrintString error:', e);
                        }
                    };
                    console.log('[JS] safeReadAndPrintString re-attached');
                } else {
                    console.log('[JS] safeReadAndPrintString is available');
                }
                if (!Module.renderPixels) {
                    console.error('[JS] renderPixels missing after runtime init! Re-attaching...');
                    // Re-attach renderPixels function
                    Module.renderPixels = function(pixelPtr) {
                        // Switch to graphics mode when rendering graphics
                        if (Module.switchToGraphicsMode) {
                            Module.switchToGraphicsMode();
                            console.log('[JS] Switched to graphics mode (re-attached)');
                        } else {
                            console.error('[JS] switchToGraphicsMode not found (re-attached)!');
                        }
                        console.log('[JS] renderPixels called with pointer:', pixelPtr);
                        var canvas = document.getElementById('osaka-canvas');
                        if (!canvas) {
                            console.error('[JS] Canvas not found!');
                            return;
                        }
                        var ctx = canvas.getContext('2d');
                        if (!ctx) {
                            console.error('[JS] Could not get 2d context!');
                            return;
                        }
                        var imageData = ctx.createImageData(320, 200);
                        var data = imageData.data;
                        var heapU8 = (typeof HEAPU8 !== 'undefined') ? HEAPU8 : window.HEAPU8;
                        if (!heapU8) {
                            console.error('[JS] No heap access available! HEAPU8 not found');
                            return;
                        }
                        if (pixelPtr < 0 || pixelPtr + 64000 > heapU8.length) {
                            console.error('[JS] renderPixels: pointer out of bounds', pixelPtr, 'heapSize:', heapU8.length);
                            return;
                        }
                        var pixels = heapU8.subarray(pixelPtr, pixelPtr + 64000);
                        for (var i = 0; i < 64000; i++) {
                            var colorIndex = pixels[i];
                            var r = 0, g = 0, b = 0;
                            if (Module.ega_palette && Module.ega_palette[colorIndex]) {
                                r = Module.ega_palette[colorIndex][0];
                                g = Module.ega_palette[colorIndex][1];
                                b = Module.ega_palette[colorIndex][2];
                            } else {
                                r = (colorIndex & 0xE0);
                                g = ((colorIndex & 0x1C) << 3);
                                b = ((colorIndex & 0x03) << 6);
                            }
                            // ImageData format: RGBA (Red, Green, Blue, Alpha) - 4 bytes per pixel
                            var idx = i * 4;
                            data[idx] = r;     // Red (0-255)
                            data[idx + 1] = g; // Green (0-255)
                            data[idx + 2] = b; // Blue (0-255)
                            data[idx + 3] = 255; // Alpha (opacity, 255 = fully opaque)
                        }
                        ctx.putImageData(imageData, 0, 0);
                        console.log('[JS] renderPixels: pixels rendered to canvas');
                    };
                    console.log('[JS] renderPixels re-attached');
                } else {
                    console.log('[JS] renderPixels is available');
                }
                if (!Module.putCharTUI) {
                    console.error('[JS] putCharTUI missing after runtime init! Re-attaching...');
                    // Re-attach putCharTUI
                    Module.putCharTUI = function(x, y, ch, fg, bg) {
                        if (Module.switchToTextMode) {
                            Module.switchToTextMode();
                        }
                        var canvas = document.getElementById('osaka-text-canvas');
                        if (!canvas) return;
                        var ctx = canvas.getContext('2d');
                        if (!ctx) return;
                        var colors = [
                            [0, 0, 0], [0, 0, 170], [0, 170, 0], [0, 170, 170],
                            [170, 0, 0], [170, 0, 170], [170, 85, 0], [170, 170, 170],
                            [85, 85, 85], [85, 85, 255], [85, 255, 85], [85, 255, 255],
                            [255, 85, 85], [255, 85, 255], [255, 255, 85], [255, 255, 255]
                        ];
                        var fgColor = colors[fg & 0x0F] || [170, 170, 170];
                        var bgColor = colors[(bg >> 4) & 0x0F] || [0, 0, 0];
                        ctx.fillStyle = 'rgb(' + bgColor.join(',') + ')';
                        ctx.fillRect(x * 8, y * 16, 8, 16);
                        var chStr = String.fromCharCode(ch);
                        if (chStr !== '\0' && chStr !== ' ') {
                            ctx.fillStyle = 'rgb(' + fgColor.join(',') + ')';
                            ctx.font = 'bold 16px monospace';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'top';
                            ctx.fillText(chStr, x * 8, y * 16);
                        }
                    };
                    console.log('[JS] putCharTUI re-attached');
                } else {
                    console.log('[JS] putCharTUI is available');
                }
                
                // Re-attach switchToGraphicsMode if missing
                if (!Module.switchToGraphicsMode) {
                    console.error('[JS] switchToGraphicsMode missing after runtime init! Re-attaching...');
                    Module.switchToGraphicsMode = function() {
                        var textCanvas = document.getElementById('osaka-text-canvas');
                        var graphicsCanvas = document.getElementById('osaka-canvas');
                        console.log('[JS] switchToGraphicsMode called (re-attached)');
                        if (textCanvas && graphicsCanvas) {
                            textCanvas.style.display = 'none';
                            graphicsCanvas.style.display = 'block';
                            console.log('[JS] Canvas switched: text hidden, graphics shown');
                            console.log('[JS] Graphics canvas computed style:', window.getComputedStyle(graphicsCanvas).display);
                        } else {
                            console.error('[JS] Canvas elements not found!', {textCanvas, graphicsCanvas});
                        }
                    };
                    console.log('[JS] switchToGraphicsMode re-attached');
                } else {
                    console.log('[JS] switchToGraphicsMode is available');
                }
                
                var loading = document.getElementById('loading');
                if (loading) {
                    loading.textContent = 'osakaOS loaded!';
                }
                
                // Check if required functions are available
                console.log('[JS] Checking available functions...');
                console.log('[JS] _kernelMain:', typeof Module._kernelMain);
                console.log('[JS] _malloc:', typeof Module._malloc);
                    console.log('[JS] HEAPU8 (global):', typeof HEAPU8, 'window.HEAPU8:', typeof window.HEAPU8);
                
                if (!Module._kernelMain) {
                    console.error('[JS] _kernelMain not found! Available functions:', Object.keys(Module).filter(k => k.startsWith('_')).slice(0, 20));
                    var status = document.getElementById('status');
                    if (status) {
                        status.textContent = 'Error: kernelMain not found';
                        status.classList.remove('hidden');
                        status.style.color = '#f00';
                    }
                    return;
                }
                
                if (typeof HEAPU8 === 'undefined' && typeof window.HEAPU8 === 'undefined') {
                    console.error('[JS] HEAPU8 not available! Cannot start kernel.');
                    var status = document.getElementById('status');
                    if (status) {
                        status.textContent = 'Error: HEAPU8 not available';
                        status.classList.remove('hidden');
                        status.style.color = '#f00';
                    }
                    return;
                }
                
                console.log('[JS] All prerequisites met, starting kernel...');
                
                // Start the kernel after a longer delay to ensure page is fully ready
                // Use requestAnimationFrame to ensure browser has rendered
                requestAnimationFrame(function() {
                    setTimeout(function() {
                        console.log('[JS] Starting kernel (delayed start)...');
                        try {
                            // Create fake multiboot structure
                            if (!Module._malloc) {
                                throw new Error('_malloc not available');
                            }
                            // Allocate multiboot structure (at least 16 uint32_t = 64 bytes)
                            // Multiboot structure format:
                            // offset 0: flags (uint32_t)
                            // offset 4: mem_lower (uint32_t) - not used
                            // offset 8: mem_upper (uint32_t) - memory upper bound in KB
                            var fakeMultiboot = Module._malloc(64);
                            if (!fakeMultiboot) {
                                throw new Error('Failed to allocate multiboot structure');
                            }
                            console.log('[JS] Allocated multiboot structure at:', fakeMultiboot);
                            
                            // Get heap access - HEAPU8 is a global variable
                            var heapBuffer;
                            if (typeof HEAPU8 !== 'undefined') {
                                heapBuffer = HEAPU8.buffer;
                            } else if (typeof window !== 'undefined' && window.HEAPU8) {
                                heapBuffer = window.HEAPU8.buffer;
                            } else if (typeof HEAP8 !== 'undefined') {
                                heapBuffer = HEAP8.buffer;
                            } else {
                                throw new Error('No heap access available - HEAPU8 not found');
                            }
                            
                            // Initialize multiboot structure
                            // Multiboot structure layout (each field is 4 bytes):
                            // [0] flags (uint32_t)
                            // [1] mem_lower (uint32_t) - not used
                            // [2] mem_upper (uint32_t) - memory upper bound in KB (at offset 8)
                            var heap = new Uint32Array(heapBuffer, fakeMultiboot, 16);
                            heap[0] = 0; // flags = 0
                            heap[1] = 0; // mem_lower = 0 (not used)
                            // mem_upper is at offset 8 bytes = index 2 in uint32_t array
                            // Value is in KB: 8MB = 8192 KB
                            heap[2] = 8192; // mem_upper = 8192 KB (8MB)
                            
                            console.log('[JS] Multiboot structure initialized:', {
                                'address': fakeMultiboot,
                                'flags': heap[0],
                                'mem_lower (KB)': heap[1],
                                'mem_upper (KB)': heap[2],
                                'mem_upper (MB)': heap[2] / 1024,
                                'offset 8 value': new DataView(heapBuffer, fakeMultiboot + 8, 4).getUint32(0, true)
                            });
                            console.log('[JS] Multiboot structure initialized');
                            
                            // Call kernelMain directly
                            console.log('[JS] Calling kernelMain with pointer:', fakeMultiboot, 'magic: 0x2BADB002');
                            console.log('[JS] HEAPU8 available:', typeof HEAPU8 !== 'undefined', 'length:', typeof HEAPU8 !== 'undefined' ? HEAPU8.length : 'N/A');
                            try {
                                var result = Module._kernelMain(fakeMultiboot, 0x2BADB002);
                                console.log('[JS] kernelMain returned:', result);
                            } catch (e) {
                                console.error('[JS] Exception calling kernelMain:', e);
                                console.error('[JS] Stack:', e.stack);
                                throw e;
                            }
                        } catch (e) {
                            console.error('[JS] Error starting kernel:', e);
                            console.error('[JS] Stack:', e.stack);
                            var status = document.getElementById('status');
                            if (status) {
                                status.textContent = 'Error starting kernel: ' + e.message;
                                status.classList.remove('hidden');
                                status.style.color = '#f00';
                            }
                        }
                    }, 500); // Longer delay to ensure page is ready
                });
            },
            onAbort: function(reason) {
                console.error('Module aborted:', reason);
                var status = document.getElementById('status');
                if (status) {
                    status.textContent = 'Error: ' + reason;
                    status.classList.remove('hidden');
                    status.style.color = '#f00';
                }
            },
            print: function(text) {
                console.log(text);
                var status = document.getElementById('status');
                if (status) {
                    status.textContent = text;
                    status.classList.remove('hidden');
                }
            },
            printErr: function(text) {
                console.error(text);
                var status = document.getElementById('status');
                if (status) {
                    status.textContent = 'Error: ' + text;
                    status.classList.remove('hidden');
                    status.style.color = '#f00';
                }
            },
            canvas: (function() {
                var canvas = document.getElementById('osaka-canvas');
                canvas.addEventListener("webglcontextlost", function(e) {
                    alert('WebGL context lost. You will need to reload the page.');
                    e.preventDefault();
                }, false);
                return canvas;
            })(),
            setStatus: function(text) {
                var loading = document.getElementById('loading');
                if (loading) {
                    loading.textContent = text;
                }
            },
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies - left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
            },
            ega_palette: [],
            noInitialRun: false,  // Let Emscripten initialize normally
            locateFile: function(path) {
                // Ensure WASM file is loaded from correct location
                if (path.endsWith('.wasm')) {
                    return 'osakaOS.wasm';
                }
                return path;
            },
            // Safe string reading function that handles out-of-bounds pointers
            safeReadAndPrintString: function(ptr) {
                if (!ptr) {
                    console.log('[JS] safeReadAndPrintString: null pointer');
                    return;
                }
                
                try {
                    // Get HEAPU8 - it might be global or on window
                    var heapU8;
                    if (typeof HEAPU8 !== 'undefined') {
                        heapU8 = HEAPU8;
                    } else if (typeof window !== 'undefined' && window.HEAPU8) {
                        heapU8 = window.HEAPU8;
                    } else {
                        console.error('[JS] safeReadAndPrintString: HEAPU8 not available');
                        return;
                    }
                    
                    var heapSize = heapU8.length;
                    if (ptr < 0 || ptr >= heapSize) {
                        console.log('[JS] safeReadAndPrintString: pointer out of bounds', ptr, 'heapSize:', heapSize);
                        return;
                    }
                    
                    var str = '';
                    var maxLen = Math.min(256, heapSize - ptr);
                    for (var i = 0; i < maxLen; i++) {
                        if (ptr + i >= heapSize) break;
                        var ch = heapU8[ptr + i];
                        if (ch === 0) break; // Null terminator
                        str += String.fromCharCode(ch);
                    }
                    
                    console.log('[JS] safeReadAndPrintString: read string:', str.substring(0, 50));
                    
                    // Now render the string character by character
                    if (!Module._printf_x) Module._printf_x = 0;
                    if (!Module._printf_y) Module._printf_y = 0;
                    
                    for (var i = 0; i < str.length; i++) {
                        var ch = str.charCodeAt(i);
                        if (ch === 10) { // newline
                            Module._printf_y++;
                            Module._printf_x = 0;
                            continue;
                        }
                        
                        if (Module.putCharTUI) {
                            Module.putCharTUI(Module._printf_x, Module._printf_y, ch, 0x07, 0x00);
                        } else {
                            console.error('[JS] Module.putCharTUI not found!');
                        }
                        
                        Module._printf_x++;
                        if (Module._printf_x >= 80) {
                            Module._printf_x = 0;
                            Module._printf_y++;
                        }
                        if (Module._printf_y >= 25) {
                            Module._printf_y = 24; // Scroll
                        }
                    }
                } catch (e) {
                    console.error('[JS] safeReadAndPrintString error:', e);
                }
            },
            // Function to render pixels to canvas
            renderPixels: function(pixelPtr) {
                // Switch to graphics mode when rendering graphics
                if (Module.switchToGraphicsMode) {
                    Module.switchToGraphicsMode();
                    console.log('[JS] Switched to graphics mode');
                } else {
                    console.error('[JS] switchToGraphicsMode not found!');
                }
                
                console.log('[JS] renderPixels called with pointer:', pixelPtr);
                var canvas = document.getElementById('osaka-canvas');
                if (!canvas) {
                    console.error('[JS] Canvas not found!');
                    return;
                }
                var ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('[JS] Could not get 2d context!');
                    return;
                }
                var imageData = ctx.createImageData(320, 200);
                var data = imageData.data;
                
                // Get heap access - HEAPU8 is a global variable
                var heapU8;
                if (typeof HEAPU8 !== 'undefined') {
                    heapU8 = HEAPU8;
                } else if (typeof window !== 'undefined' && window.HEAPU8) {
                    heapU8 = window.HEAPU8;
                } else if (typeof HEAP8 !== 'undefined') {
                    heapU8 = HEAP8;
                } else {
                    console.error('[JS] No heap access available! HEAPU8 not found');
                    return;
                }
                
                if (pixelPtr < 0 || pixelPtr + 64000 > heapU8.length) {
                    console.error('[JS] renderPixels: pointer out of bounds', pixelPtr, 'heapSize:', heapU8.length);
                    return;
                }
                
                var pixels = heapU8.subarray(pixelPtr, pixelPtr + 64000);
                console.log('[JS] Pixels array length:', pixels.length, 'first few values:', pixels[0], pixels[1], pixels[2]);
                
                for (var i = 0; i < 64000; i++) {
                    var colorIndex = pixels[i];
                    var r = 0, g = 0, b = 0;
                    
                    // Use EGA palette if available
                    // Palette format: [Red, Green, Blue]
                    if (Module.ega_palette && Module.ega_palette[colorIndex]) {
                        r = Module.ega_palette[colorIndex][0]; // Red
                        g = Module.ega_palette[colorIndex][1]; // Green
                        b = Module.ega_palette[colorIndex][2]; // Blue
                    } else {
                        // Fallback: simple color mapping
                        r = (colorIndex & 0xE0);
                        g = ((colorIndex & 0x1C) << 3);
                        b = ((colorIndex & 0x03) << 6);
                    }
                    
                    var idx = i * 4;
                    data[idx] = r;     // R
                    data[idx + 1] = g; // G
                    data[idx + 2] = b; // B
                    data[idx + 3] = 255; // A
                }
                
                ctx.putImageData(imageData, 0, 0);
                console.log('[JS] Canvas updated successfully, rendered', 64000, 'pixels');
            }
        };
        
        // Function to switch to text mode (show text canvas, hide graphics canvas)
        Module.switchToTextMode = function() {
            var textCanvas = document.getElementById('osaka-text-canvas');
            var graphicsCanvas = document.getElementById('osaka-canvas');
            if (textCanvas && graphicsCanvas) {
                textCanvas.style.display = 'block';
                graphicsCanvas.style.display = 'none';
                // Focus the text canvas so it can receive keyboard events
                textCanvas.focus();
            }
        };
        
        // Function to switch to graphics mode (show graphics canvas, hide text canvas)
        Module.switchToGraphicsMode = function() {
            var textCanvas = document.getElementById('osaka-text-canvas');
            var graphicsCanvas = document.getElementById('osaka-canvas');
            console.log('[JS] switchToGraphicsMode called');
            if (textCanvas && graphicsCanvas) {
                textCanvas.style.display = 'none';
                graphicsCanvas.style.display = 'block';
                console.log('[JS] Canvas switched: text hidden, graphics shown');
                console.log('[JS] Graphics canvas computed style:', window.getComputedStyle(graphicsCanvas).display);
                // Focus the graphics canvas so it can receive keyboard events
                graphicsCanvas.focus();
            } else {
                console.error('[JS] Canvas elements not found!', {textCanvas, graphicsCanvas});
            }
        };
        
        // Function to render a character to text canvas
        Module.putCharTUI = function(x, y, ch, fg, bg) {
            // Switch to text mode when rendering text
            if (Module.switchToTextMode) {
                Module.switchToTextMode();
            }
            
            var canvas = document.getElementById('osaka-text-canvas');
            if (!canvas) {
                console.error('[JS] putCharTUI: canvas not found!');
                return;
            }
            var ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('[JS] putCharTUI: could not get 2d context!');
                return;
            }
            
            // EGA color palette for text mode
            var colors = [
                [0, 0, 0],       // 0: Black
                [0, 0, 170],     // 1: Blue
                [0, 170, 0],     // 2: Green
                [0, 170, 170],   // 3: Cyan
                [170, 0, 0],     // 4: Red
                [170, 0, 170],   // 5: Magenta
                [170, 85, 0],    // 6: Brown
                [170, 170, 170], // 7: Light Gray
                [85, 85, 85],    // 8: Dark Gray
                [85, 85, 255],   // 9: Light Blue
                [85, 255, 85],   // 10: Light Green
                [85, 255, 255],  // 11: Light Cyan
                [255, 85, 85],   // 12: Light Red
                [255, 85, 255],  // 13: Light Magenta
                [255, 255, 85],  // 14: Yellow
                [255, 255, 255]  // 15: White
            ];
            
            var fgColor = colors[fg & 0x0F] || [170, 170, 170];
            var bgColor = colors[(bg >> 4) & 0x0F] || [0, 0, 0];
            
            // Fill background
            ctx.fillStyle = 'rgb(' + bgColor.join(',') + ')';
            ctx.fillRect(x * 8, y * 16, 8, 16);
            
            // Draw character
            var chStr = String.fromCharCode(ch);
            if (chStr !== '\0' && chStr !== ' ') {
                ctx.fillStyle = 'rgb(' + fgColor.join(',') + ')';
                ctx.font = 'bold 16px monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(chStr, x * 8, y * 16);
            }
        };
        
        // Function to clear text canvas
        Module.clearTextCanvas = function() {
            var canvas = document.getElementById('osaka-text-canvas');
            if (canvas) {
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgb(0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };
        
        // Network functions for JavaScript-based networking
        Module.networkPackets = [];
        Module.networkIP = {ip1: 10, ip2: 0, ip3: 2, ip4: 15};
        Module.networkMAC = 0x020000000000;
        
        // Set network IP address
        Module.setNetworkIP = function(ip4, ip3, ip2, ip1) {
            Module.networkIP = {ip1: ip1, ip2: ip2, ip3: ip3, ip4: ip4};
            console.log('[JS] Network IP set to:', ip4 + '.' + ip3 + '.' + ip2 + '.' + ip1);
        };
        
        // Get network MAC address
        Module.getNetworkMAC = function() {
            // Return MAC as 48-bit integer (high 16 bits are 0x0200)
            return Module.networkMAC;
        };
        
        // Send network packet via fetch API (simulating HTTP)
        Module.sendNetworkPacket = function(packet) {
            try {
                // Parse Ethernet frame
                if (packet.length < 14) return; // Minimum Ethernet header size
                
                // Extract destination MAC (bytes 0-5)
                var dstMac = 0;
                for (var i = 0; i < 6; i++) {
                    dstMac = (dstMac << 8) | packet[i];
                }
                
                // Extract source MAC (bytes 6-11)
                var srcMac = 0;
                for (var i = 6; i < 12; i++) {
                    srcMac = (srcMac << 8) | packet[i];
                }
                
                // Extract EtherType (bytes 12-13)
                var etherType = (packet[12] << 8) | packet[13];
                
                // For IPv4 (0x0800), extract IP packet
                if (etherType === 0x0800 && packet.length >= 34) {
                    // Extract destination IP (bytes 30-33 in Ethernet frame, bytes 16-19 in IP header)
                    var dstIP = packet[30] + '.' + packet[31] + '.' + packet[32] + '.' + packet[33];
                    var protocol = packet[23]; // IP protocol field
                    
                    // For TCP (6) or UDP (17), we could make HTTP requests
                    // For now, just log it
                    console.log('[JS] Network packet:', {
                        dstMac: '0x' + dstMac.toString(16),
                        srcMac: '0x' + srcMac.toString(16),
                        etherType: '0x' + etherType.toString(16),
                        dstIP: dstIP,
                        protocol: protocol,
                        size: packet.length
                    });
                    
                    // TODO: Implement actual HTTP/TCP networking here
                    // For now, this is a placeholder
                }
            } catch (e) {
                console.error('[JS] Error in sendNetworkPacket:', e);
            }
        };
        
        // Poll for received network packets
        Module.pollNetworkPackets = function() {
            // Check if there are any packets in the queue
            if (Module.networkPackets.length > 0) {
                var packet = Module.networkPackets.shift();
                // Notify C++ side of received packet
                if (Module.onNetworkPacketReceived) {
                    Module.onNetworkPacketReceived(packet.ptr, packet.size);
                }
            }
        };
        
        // Function to simulate receiving a network packet (can be called from external code)
        Module.simulateNetworkPacket = function(data) {
            // Allocate memory in WASM heap for the packet
            if (!Module._malloc) return;
            
            var size = data.length;
            var ptr = Module._malloc(size);
            if (!ptr) return;
            
            // Copy data to WASM heap
            var heap = new Uint8Array(HEAPU8.buffer, ptr, size);
            heap.set(data);
            
            // Queue the packet
            Module.networkPackets.push({ptr: ptr, size: size});
        };
        
        // Safe string reading function that handles out-of-bounds pointers
        Module.safeReadAndPrintString = function(ptr) {
            if (!ptr) return;
            
            try {
                var heapSize = HEAPU8.length;
                if (ptr < 0 || ptr >= heapSize) {
                    // Pointer is outside heap bounds, skip silently
                    return;
                }
                
                var str = '';
                var maxLen = Math.min(256, heapSize - ptr);
                for (var i = 0; i < maxLen; i++) {
                    if (ptr + i >= heapSize) break;
                    var ch = HEAPU8[ptr + i];
                    if (ch === 0) break; // Null terminator
                    str += String.fromCharCode(ch);
                }
                
                // Now render the string character by character
                if (!Module._printf_x) Module._printf_x = 0;
                if (!Module._printf_y) Module._printf_y = 0;
                
                for (var i = 0; i < str.length; i++) {
                    var ch = str.charCodeAt(i);
                    if (ch === 10) { // newline
                        Module._printf_y++;
                        Module._printf_x = 0;
                        continue;
                    }
                    
                    if (Module.putCharTUI) {
                        Module.putCharTUI(Module._printf_x, Module._printf_y, ch, 0x07, 0x00);
                    }
                    
                    Module._printf_x++;
                    if (Module._printf_x >= 80) {
                        Module._printf_x = 0;
                        Module._printf_y++;
                    }
                    if (Module._printf_y >= 25) {
                        Module._printf_y = 24; // Scroll
                    }
                }
            } catch (e) {
                // Silently fail - string might be in inaccessible memory
            }
        };
        
        // Function to render pixels to canvas
        Module.renderPixels = function(pixelPtr) {
            console.log('[JS] renderPixels called with pointer:', pixelPtr);
            var canvas = document.getElementById('osaka-canvas');
            if (!canvas) {
                console.error('[JS] Canvas not found!');
                return;
            }
            var ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('[JS] Could not get 2d context!');
                return;
            }
            var imageData = ctx.createImageData(320, 200);
            var data = imageData.data;
            
            // Get heap access - HEAPU8 is a global variable
            var heapU8;
            if (typeof HEAPU8 !== 'undefined') {
                heapU8 = HEAPU8;
            } else if (typeof window !== 'undefined' && window.HEAPU8) {
                heapU8 = window.HEAPU8;
            } else if (typeof HEAP8 !== 'undefined') {
                heapU8 = HEAP8;
            } else {
                console.error('[JS] No heap access available! HEAPU8 not found');
                return;
            }
            
            if (pixelPtr < 0 || pixelPtr + 64000 > heapU8.length) {
                console.error('[JS] renderPixels: pointer out of bounds', pixelPtr, 'heapSize:', heapU8.length);
                return;
            }
            
            var pixels = heapU8.subarray(pixelPtr, pixelPtr + 64000);
            console.log('[JS] Pixels array length:', pixels.length, 'first few values:', pixels[0], pixels[1], pixels[2]);
            
            for (var i = 0; i < 64000; i++) {
                var colorIdx = pixels[i];
                var rVal = 0, gVal = 0, bVal = 0;
                
                // Palette format: [Red, Green, Blue]
                if (Module.ega_palette && Module.ega_palette[colorIdx] && Array.isArray(Module.ega_palette[colorIdx])) {
                    rVal = Module.ega_palette[colorIdx][0]; // Red
                    gVal = Module.ega_palette[colorIdx][1]; // Green
                    bVal = Module.ega_palette[colorIdx][2]; // Blue
                } else {
                    console.log('[JS] Fallback: calculating color on the fly');
                    // Fallback: calculate color on the fly (shouldn't happen if palette is initialized)
                    var color = colorIdx;
                    var r6 = 0, g6 = 0, b6 = 0;
                    switch (Math.floor(color / 64)) {
                        case 0:
                            r6 = (color & 0x20 ? 0x15 : 0) | (color & 0x04 ? 0x2a : 0);
                            g6 = (color & 0x10 ? 0x15 : 0) | (color & 0x02 ? 0x2a : 0);
                            b6 = (color & 0x08 ? 0x15 : 0) | (color & 0x01 ? 0x2a : 0);
                            break;
                        case 1:
                            r6 = ((color & 0x20 ? 0x15 : 0) | (color & 0x04 ? 0x2a : 0)) >> 3;
                            g6 = ((color & 0x10 ? 0x15 : 0) | (color & 0x02 ? 0x2a : 0)) >> 3;
                            b6 = ((color & 0x08 ? 0x15 : 0) | (color & 0x01 ? 0x2a : 0)) >> 3;
                            break;
                        case 2:
                            r6 = ((color & 0x20 ? 0x15 : 0) | (color & 0x04 ? 0x2a : 0)) << 3;
                            g6 = ((color & 0x10 ? 0x15 : 0) | (color & 0x02 ? 0x2a : 0)) << 3;
                            b6 = ((color & 0x08 ? 0x15 : 0) | (color & 0x01 ? 0x2a : 0)) << 3;
                            if (r6 > 63) r6 = 63;
                            if (g6 > 63) g6 = 63;
                            if (b6 > 63) b6 = 63;
                            break;
                        default:
                            r6 = g6 = b6 = 0;
                            break;
                    }
                    // Scale 6-bit to 8-bit
                    rVal = r6 * 4;
                    gVal = g6 * 4;
                    bVal = b6 * 4;
                }
                
                // ImageData format: RGBA (Red, Green, Blue, Alpha) - 4 bytes per pixel
                var idx = i * 4;
                data[idx] = rVal;     // Red (0-255)
                data[idx + 1] = gVal; // Green (0-255)
                data[idx + 2] = bVal; // Blue (0-255)
                data[idx + 3] = 255;  // Alpha (opacity, 255 = fully opaque)
            }
            
            ctx.putImageData(imageData, 0, 0);
            console.log('[JS] Canvas updated successfully');
        };
        
        // Initialize EGA palette - use the same calculation as the original VGA driver
        // VGA writes 6-bit values (0-63) to palette registers, which need to be scaled to 8-bit (0-255)
        // Scale factor: 255/63 â‰ˆ 4.048, but we use 4 for exact match with QEMU
        // Ensure palette array exists
        if (!Module.ega_palette || Module.ega_palette.length === 0) {
            Module.ega_palette = [];
        }
        
        for (var i = 0; i < 256; i++) {
            var r6 = 0, g6 = 0, b6 = 0; // 6-bit values (0-63)
            var r = 0, g = 0, b = 0;     // 8-bit values (0-255)
            switch (Math.floor(i / 64)) {
                case 0:
                    r6 = (i & 0x20 ? 0x15 : 0) | (i & 0x04 ? 0x2a : 0);
                    g6 = (i & 0x10 ? 0x15 : 0) | (i & 0x02 ? 0x2a : 0);
                    b6 = (i & 0x08 ? 0x15 : 0) | (i & 0x01 ? 0x2a : 0);
                    // Scale 6-bit to 8-bit: multiply by 4
                    r = r6 * 4;
                    g = g6 * 4;
                    b = b6 * 4;
                    break;
                case 1:
                    r6 = ((i & 0x20 ? 0x15 : 0) | (i & 0x04 ? 0x2a : 0)) >> 3;
                    g6 = ((i & 0x10 ? 0x15 : 0) | (i & 0x02 ? 0x2a : 0)) >> 3;
                    b6 = ((i & 0x08 ? 0x15 : 0) | (i & 0x01 ? 0x2a : 0)) >> 3;
                    r = r6 * 4;
                    g = g6 * 4;
                    b = b6 * 4;
                    break;
                case 2:
                    r6 = ((i & 0x20 ? 0x15 : 0) | (i & 0x04 ? 0x2a : 0)) << 3;
                    g6 = ((i & 0x10 ? 0x15 : 0) | (i & 0x02 ? 0x2a : 0)) << 3;
                    b6 = ((i & 0x08 ? 0x15 : 0) | (i & 0x01 ? 0x2a : 0)) << 3;
                    // Clamp to 63 (6-bit max) before scaling
                    if (r6 > 63) r6 = 63;
                    if (g6 > 63) g6 = 63;
                    if (b6 > 63) b6 = 63;
                    r = r6 * 4;
                    g = g6 * 4;
                    b = b6 * 4;
                    break;
                default:
                    r = g = b = 0;
                    break;
            }
            Module.ega_palette[i] = [r, g, b];
        }
        
        // Debug: verify color 0 is black
        console.log('[JS] EGA palette initialized. Color 0 (black):', Module.ega_palette[0]);
        if (Module.ega_palette[0][0] !== 0 || Module.ega_palette[0][1] !== 0 || Module.ega_palette[0][2] !== 0) {
            console.error('[JS] ERROR: Color 0 is not black!', Module.ega_palette[0]);
        }
        
        // Iframe app helper functions - store in window for re-attachment
        window.setupIframeAppFunction = function(urlPtr, iframeId, widgetX, widgetY, widgetW, widgetH) {
            console.log('[IframeApp JS] setupIframeApp called', {
                urlPtr: urlPtr,
                iframeId: iframeId,
                widgetX: widgetX,
                widgetY: widgetY,
                widgetW: widgetW,
                widgetH: widgetH
            });
            
            // Read URL from WASM memory
            var url = '';
            if (urlPtr) {
                var heapU8 = (typeof HEAPU8 !== 'undefined') ? HEAPU8 : window.HEAPU8;
                if (heapU8) {
                    var i = 0;
                    while (heapU8[urlPtr + i] !== 0 && i < 256) {
                        url += String.fromCharCode(heapU8[urlPtr + i]);
                        i++;
                    }
                }
            }
            
            console.log('[IframeApp JS] URL read:', url);
            
            var iframeIdStr = 'osaka_iframe_' + iframeId;
            var captureCanvasId = 'osaka_capture_' + iframeId;
            
            // Remove existing elements
            var existingIframe = document.getElementById(iframeIdStr);
            if (existingIframe) existingIframe.parentNode.removeChild(existingIframe);
            var existingCanvas = document.getElementById(captureCanvasId);
            if (existingCanvas) existingCanvas.parentNode.removeChild(existingCanvas);
            
            // Create iframe - will be positioned based on same-origin vs cross-origin
            var iframe = document.createElement('iframe');
            iframe.id = iframeIdStr;
            iframe.src = url;
            iframe.style.position = 'absolute';
            iframe.style.border = 'none';
            iframe.style.pointerEvents = 'auto';
            // Initially hidden, will be shown if cross-origin or positioned if same-origin
            iframe.style.visibility = 'hidden';
            iframe.style.left = '-9999px';
            iframe.style.top = '-9999px';
            iframe.style.width = widgetW + 'px';
            iframe.style.height = widgetH + 'px';
            iframe.style.zIndex = '1000';
            
            // Create capture canvas
            var captureCanvas = document.createElement('canvas');
            captureCanvas.id = captureCanvasId;
            captureCanvas.width = widgetW;
            captureCanvas.height = widgetH;
            captureCanvas.style.position = 'absolute';
            captureCanvas.style.left = '-9999px';
            captureCanvas.style.top = '-9999px';
            
            document.body.appendChild(iframe);
            document.body.appendChild(captureCanvas);
            
            // Store app reference
            if (!Module.iframeApps) {
                Module.iframeApps = {};
            }
            Module.iframeApps[iframeId] = {
                iframe: iframe,
                captureCanvas: captureCanvas,
                widgetX: widgetX,
                widgetY: widgetY,
                widgetW: widgetW,
                widgetH: widgetH
            };
            
            // Start capture when iframe loads
            iframe.onload = function() {
                console.log('[IframeApp JS] Iframe loaded:', url);
                
                // Check if we can access the iframe content (same-origin check)
                var canAccess = false;
                try {
                    var testDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (testDoc && testDoc.body) {
                        canAccess = true;
                    }
                } catch(e) {
                    // Cross-origin - can't access
                    canAccess = false;
                }
                
                if (canAccess) {
                    // Same-origin: capture and render to canvas
                    console.log('[IframeApp JS] Same-origin iframe, using capture');
                    var captureFrame = function() {
                        try {
                            var app = Module.iframeApps[iframeId];
                            if (!app || !app.iframe || !app.captureCanvas) return;
                            
                            var ctx = app.captureCanvas.getContext('2d');
                            try {
                                // Try to capture iframe content
                                var iframeDoc = app.iframe.contentDocument || app.iframe.contentWindow.document;
                                if (iframeDoc && iframeDoc.body) {
                                    // Same-origin: try to capture using html2canvas if available
                                    if (typeof html2canvas !== 'undefined') {
                                        html2canvas(iframeDoc.body, {
                                            canvas: app.captureCanvas,
                                            width: app.widgetW,
                                            height: app.widgetH,
                                            scale: 1,
                                            useCORS: true
                                        }).then(function(canvas) {
                                            // Canvas is already updated
                                        }).catch(function(e) {
                                            console.log('[IframeApp] html2canvas error:', e);
                                            // Fallback: draw placeholder
                                            ctx.fillStyle = '#333';
                                            ctx.fillRect(0, 0, app.widgetW, app.widgetH);
                                            ctx.fillStyle = '#fff';
                                            ctx.font = '12px monospace';
                                            ctx.fillText('Capture failed', 10, 20);
                                        });
                                    } else {
                                        // No html2canvas: try direct drawImage
                                        try {
                                            ctx.drawImage(app.iframe, 0, 0, app.widgetW, app.widgetH);
                                        } catch(e) {
                                            // Fallback: render iframe body to canvas manually
                                            ctx.fillStyle = '#333';
                                            ctx.fillRect(0, 0, app.widgetW, app.widgetH);
                                            ctx.fillStyle = '#fff';
                                            ctx.font = '12px monospace';
                                            ctx.fillText('Iframe loaded', 10, 20);
                                        }
                                    }
                                }
                            } catch(e) {
                                console.log('[IframeApp] Capture error:', e);
                            }
                        } catch(e) {
                            console.log('[IframeApp] Frame capture error:', e);
                        }
                    };
                    
                    // Start capture loop
                    Module.iframeApps[iframeId].captureInterval = setInterval(captureFrame, 100);
                    // Also capture immediately
                    captureFrame();
                } else {
                    // Cross-origin: can't capture, but display iframe directly over window
                    console.log('[IframeApp JS] Cross-origin iframe, displaying directly over window');
                    Module.iframeApps[iframeId].isCrossOrigin = true;
                    
                    // Function to update iframe position over the window
                    function updateIframePosition(iframeId) {
                        var app = Module.iframeApps ? Module.iframeApps[iframeId] : null;
                        if (!app || !app.iframe) return;
                        
                        // Get the OS canvas to calculate position
                        var canvas = document.getElementById('osaka-canvas');
                        if (!canvas) return;
                        
                        var canvasRect = canvas.getBoundingClientRect();
                        var scaleX = canvasRect.width / 320;
                        var scaleY = canvasRect.height / 200;
                        
                        // Calculate screen position for the window content area
                        // Window content starts at (widgetX + 1, widgetY + 10) with size (widgetW - 1, widgetH - 10)
                        var contentX = app.widgetX + 1;
                        var contentY = app.widgetY + 10;
                        var contentW = Math.max(1, app.widgetW - 1);
                        var contentH = Math.max(1, app.widgetH - 10);
                        
                        var screenX = canvasRect.left + (contentX * scaleX);
                        var screenY = canvasRect.top + (contentY * scaleY);
                        var screenW = Math.max(1, contentW * scaleX);
                        var screenH = Math.max(1, contentH * scaleY);
                        
                        app.iframe.style.left = screenX + 'px';
                        app.iframe.style.top = screenY + 'px';
                        app.iframe.style.width = screenW + 'px';
                        app.iframe.style.height = screenH + 'px';
                        app.iframe.style.visibility = 'visible';
                        app.iframe.style.zIndex = '1000';
                        app.iframe.style.pointerEvents = 'auto';
                    }
                    
                    // Position iframe immediately
                    updateIframePosition(iframeId);
                    
                    // Store update function for later calls (when window moves/resizes)
                    Module.iframeApps[iframeId].updatePosition = function() {
                        updateIframePosition(iframeId);
                    };
                    
                    // Also update position periodically in case window moves
                    Module.iframeApps[iframeId].positionInterval = setInterval(function() {
                        updateIframePosition(iframeId);
                    }, 100);
                }
            };
        };
        
        // Attach to Module initially
        Module.setupIframeApp = window.setupIframeAppFunction;
        
        // Store in window for re-attachment
        window.captureIframeToBufferFunction = function(iframeId, offsetX, offsetY, contentW, contentH, bufferPtr) {
            var app = Module.iframeApps ? Module.iframeApps[iframeId] : null;
            if (!app) {
                console.error('[IframeApp JS] captureIframeToBuffer: app not found', iframeId);
                return;
            }
            
            // If cross-origin, update iframe position and skip capture (iframe is displayed directly)
            if (app.isCrossOrigin) {
                // Update widget coordinates from parameters (they're passed from C++)
                // The widget coordinates are already updated in the EM_ASM_ call above
                if (app.updatePosition) {
                    app.updatePosition();
                }
                // Don't write anything to buffer - the iframe is displayed as an overlay
                return;
            }
            
            // Same-origin: proceed with capture
            if (!app.captureCanvas || !bufferPtr) {
                console.error('[IframeApp JS] captureIframeToBuffer: missing canvas/buffer', {
                    hasCanvas: !!app.captureCanvas,
                    bufferPtr: bufferPtr
                });
                return;
            }
            
            console.log('[IframeApp JS] App found, proceeding with capture');
            
            var captureCanvas = app.captureCanvas;
            var ctx = captureCanvas.getContext('2d');
            
            // Check if canvas has any content
            var imageData = ctx.getImageData(0, 0, app.widgetW, app.widgetH);
            var data = imageData.data;
            
            // Check if canvas is all white/empty
            var hasContent = false;
            for (var i = 0; i < data.length; i += 4) {
                if (data[i] !== 255 || data[i+1] !== 255 || data[i+2] !== 255) {
                    hasContent = true;
                    break;
                }
            }
            
            if (!hasContent) {
                console.log('[IframeApp JS] Canvas is empty, drawing placeholder');
                // Canvas is empty/white - fill with a test pattern to verify buffer writing works
                ctx.fillStyle = '#444';
                ctx.fillRect(0, 0, app.widgetW, app.widgetH);
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText('Loading iframe...', 10, 20);
                ctx.fillText('Size: ' + app.widgetW + 'x' + app.widgetH, 10, 35);
                // Re-read image data after drawing
                imageData = ctx.getImageData(0, 0, app.widgetW, app.widgetH);
                data = imageData.data;
            }
            
            var heapU8 = (typeof HEAPU8 !== 'undefined') ? HEAPU8 : window.HEAPU8;
            if (!heapU8) {
                console.error('[IframeApp] HEAPU8 not available');
                return;
            }
            
            // Convert captured pixels to OS palette and write to buffer
            // The buffer is 320x200, and we write starting at (offsetX, offsetY) with size (contentW, contentH)
            // The buffer index calculation is: (y << 8) + (y << 6) + x = y * 320 + x
            var pixelsWritten = 0;
            var maxX = Math.min(contentW, app.widgetW);
            var maxY = Math.min(contentH, app.widgetH);
            
            for (var y = 0; y < maxY && (offsetY + y) < 200; y++) {
                for (var x = 0; x < maxX && (offsetX + x) < 320; x++) {
                    var srcIdx = (y * app.widgetW + x) * 4;
                    var r = data[srcIdx];
                    var g = data[srcIdx + 1];
                    var b = data[srcIdx + 2];
                    
                    // Find closest EGA palette color
                    var bestColor = 0;
                    var bestDist = Infinity;
                    
                    if (Module.ega_palette) {
                        for (var i = 0; i < 256; i++) {
                            var palR = Module.ega_palette[i][0];
                            var palG = Module.ega_palette[i][1];
                            var palB = Module.ega_palette[i][2];
                            
                            var dist = Math.sqrt(
                                Math.pow(r - palR, 2) +
                                Math.pow(g - palG, 2) +
                                Math.pow(b - palB, 2)
                            );
                            
                            if (dist < bestDist) {
                                bestDist = dist;
                                bestColor = i;
                            }
                        }
                    }
                    
                    // Write to window buffer at (offsetX + x, offsetY + y)
                    var bufX = offsetX + x;
                    var bufY = offsetY + y;
                    if (bufX >= 0 && bufX < 320 && bufY >= 0 && bufY < 200) {
                        // Buffer index calculation: (bufY << 8) + (bufY << 6) + bufX = bufY * 320 + bufX
                        var bufIdx = (bufY << 8) + (bufY << 6) + bufX;
                        if (bufferPtr + bufIdx < heapU8.length) {
                            heapU8[bufferPtr + bufIdx] = bestColor;
                            pixelsWritten++;
                        }
                    }
                }
            }
            
            console.log('[IframeApp JS] Wrote', pixelsWritten, 'pixels to buffer');
            
            if (pixelsWritten === 0) {
                console.error('[IframeApp JS] No pixels written!', {
                    offsetX: offsetX,
                    offsetY: offsetY,
                    contentW: contentW,
                    contentH: contentH,
                    bufferPtr: bufferPtr,
                    heapSize: heapU8.length,
                    widgetW: app.widgetW,
                    widgetH: app.widgetH
                });
            }
        };
        
        // Attach to Module initially
        Module.captureIframeToBuffer = window.captureIframeToBufferFunction;
        
        // Store in window for re-attachment
        window.forwardKeyToIframeFunction = function(iframeId, keyCode, eventType) {
            var app = Module.iframeApps ? Module.iframeApps[iframeId] : null;
            if (!app || !app.iframe) return;
            
            try {
                var iframeWindow = app.iframe.contentWindow;
                if (iframeWindow) {
                    var keyEvent = new KeyboardEvent(eventType, {
                        keyCode: keyCode,
                        which: keyCode,
                        bubbles: true,
                        cancelable: true
                    });
                    iframeWindow.dispatchEvent(keyEvent);
                }
            } catch(e) {
                // Cross-origin restriction
            }
        };
        
        // Attach to Module initially
        Module.forwardKeyToIframe = window.forwardKeyToIframeFunction;
        
        // Store in window for re-attachment
        window.forwardMouseToIframeFunction = function(iframeId, mouseX, mouseY, button, widgetX, widgetY, eventType) {
            var app = Module.iframeApps ? Module.iframeApps[iframeId] : null;
            if (!app || !app.iframe) return;
            
            try {
                var iframeWindow = app.iframe.contentWindow;
                var iframeDoc = app.iframe.contentDocument || iframeWindow.document;
                if (!iframeDoc) return;
                
                var iframeX = mouseX - widgetX;
                var iframeY = mouseY - widgetY;
                
                var mouseEvent = new MouseEvent(eventType, {
                    clientX: iframeX,
                    clientY: iframeY,
                    button: button,
                    bubbles: true,
                    cancelable: true
                });
                iframeDoc.dispatchEvent(mouseEvent);
            } catch(e) {
                // Cross-origin restriction
            }
        };
        
        // Attach to Module initially
        Module.forwardMouseToIframe = window.forwardMouseToIframeFunction;
        
        // Setup canvas scaling
        window.addEventListener('load', function() {
            var canvas = document.getElementById('osaka-canvas');
            var textCanvas = document.getElementById('osaka-text-canvas');
            
            function resizeCanvas() {
                var scale = Math.min(
                    (window.innerWidth - 40) / 320,
                    (window.innerHeight - 200) / 200
                );
                scale = Math.max(1, Math.floor(scale));
                canvas.style.width = (320 * scale) + 'px';
                canvas.style.height = (200 * scale) + 'px';
                
                if (textCanvas) {
                    textCanvas.style.width = (640 * scale) + 'px';
                    textCanvas.style.height = (400 * scale) + 'px';
                }
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        });
    </script>
    <!-- Load script asynchronously to prevent blocking -->
    <script>
        // Load the module script asynchronously
        var script = document.createElement('script');
        script.src = 'osakaOS.js';
        script.async = true;
        script.onerror = function() {
            console.error('Failed to load osakaOS.js');
            var status = document.getElementById('status');
            if (status) {
                status.textContent = 'Failed to load osakaOS.js';
                status.classList.remove('hidden');
                status.style.color = '#f00';
            }
        };
        script.onload = function() {
            console.log('[JS] osakaOS.js loaded');
            
            // Wait a bit for the script to execute
            setTimeout(function() {
                console.log('[JS] Checking module state after script load...');
                console.log('[JS] Module:', typeof Module !== 'undefined' ? 'defined' : 'undefined');
                console.log('[JS] Module.ready:', typeof Module !== 'undefined' && Module.ready);
                console.log('[JS] Module.calledRun:', typeof Module !== 'undefined' && Module.calledRun);
                
                // Poll for module initialization since onRuntimeInitialized might not fire
                var checkCount = 0;
                var checkInterval = setInterval(function() {
                    checkCount++;
                    if (checkCount > 100) { // Stop after 10 seconds (100 * 100ms)
                        clearInterval(checkInterval);
                        return;
                    }
                    
                    if (typeof Module !== 'undefined') {
                        // Check if runtime is initialized - HEAPU8 is a global variable
                        var hasHeap = typeof HEAPU8 !== 'undefined' || typeof window.HEAPU8 !== 'undefined';
                        var hasKernelMain = typeof Module._kernelMain !== 'undefined';
                        var hasMalloc = typeof Module._malloc !== 'undefined';
                        
                        if (checkCount % 10 === 0) { // Log every second
                            console.log('[JS] Polling... HEAPU8 (global):', typeof HEAPU8, 'window.HEAPU8:', typeof window.HEAPU8, '_kernelMain:', hasKernelMain, '_malloc:', hasMalloc);
                        }
                        
                        if (hasHeap && hasKernelMain && hasMalloc) {
                            console.log('[JS] Module fully initialized (HEAPU8 and _kernelMain available)!');
                            clearInterval(checkInterval);
                            if (Module.onRuntimeInitialized && !moduleInitialized) {
                                Module.onRuntimeInitialized();
                            }
                        }
                    }
                }, 100);
            }, 500); // Wait 500ms for script to execute
        };
        document.head.appendChild(script);
        
        // Initialize palette after Module is defined
        if (typeof Module !== 'undefined') {
            initializeEGAPalette();
        }
        
        // Track module initialization - wait for Module to be defined
        var moduleInitialized = false;
        var originalOnRuntimeInitialized = null;
        
        // Capture the original onRuntimeInitialized safely
        if (typeof Module !== 'undefined' && Module.onRuntimeInitialized) {
            originalOnRuntimeInitialized = Module.onRuntimeInitialized;
        }
        
        // Wrap the onRuntimeInitialized to add logging
        if (typeof Module !== 'undefined') {
            Module.onRuntimeInitialized = function() {
                console.log('[JS] onRuntimeInitialized wrapper called');
                console.log('[JS] Module state - _kernelMain:', typeof Module._kernelMain, 'HEAPU8:', typeof HEAPU8);
                moduleInitialized = true;
                
                // Re-initialize palette in case it was overwritten
                initializeEGAPalette();
                
                // Always call the original - it has the kernel startup code
                if (originalOnRuntimeInitialized) {
                    console.log('[JS] Calling original onRuntimeInitialized (has kernel startup code)...');
                    originalOnRuntimeInitialized();
                } else {
                    console.error('[JS] ERROR: originalOnRuntimeInitialized is undefined!');
                    console.error('[JS] This should not happen - the kernel startup code is missing!');
                    // Fallback: try to start kernel directly
                    if (Module._kernelMain && typeof HEAPU8 !== 'undefined') {
                        console.log('[JS] Attempting to start kernel directly as fallback...');
                        try {
                            var fakeMultiboot = Module._malloc(16 * 4);
                            var heap = new Uint32Array(HEAPU8.buffer, fakeMultiboot, 16);
                            heap[0] = 0;
                            heap[1] = 0x800000;
                            Module._kernelMain(fakeMultiboot, 0x2BADB002);
                            console.log('[JS] Fallback kernel start succeeded');
                        } catch (e) {
                            console.error('[JS] Fallback kernel start failed:', e);
                            console.error('[JS] Stack:', e.stack);
                        }
                    }
                }
            };
        } else {
            console.error('[JS] Module is undefined! Cannot initialize palette or wrap onRuntimeInitialized');
        }
        
        // Fallback if module doesn't load
        setTimeout(function() {
            if (!moduleInitialized) {
                console.error('[JS] Module failed to initialize after 10 seconds');
                console.log('[JS] Module state:', {
                    defined: typeof Module !== 'undefined',
                    hasHEAP8: typeof HEAP8 !== 'undefined',
                    hasHEAPU8: typeof HEAPU8 !== 'undefined' || typeof window.HEAPU8 !== 'undefined',
                    has_asm: typeof Module !== 'undefined' && typeof Module.asm !== 'undefined',
                    has_kernelMain: typeof Module !== 'undefined' && typeof Module._kernelMain !== 'undefined'
                });
                
                // Try to manually trigger if we have the essentials
                var heapAvailable = typeof HEAPU8 !== 'undefined' || typeof window.HEAPU8 !== 'undefined';
                if (typeof Module !== 'undefined' && Module._kernelMain && heapAvailable && !moduleInitialized) {
                    console.log('[JS] Module appears ready, starting kernel directly...');
                    moduleInitialized = true;
                    
                    // Call original onRuntimeInitialized if available
                    if (originalOnRuntimeInitialized) {
                        console.log('[JS] Calling original onRuntimeInitialized...');
                        originalOnRuntimeInitialized();
                    } else {
                        // Start kernel directly
                        console.log('[JS] Starting kernel directly (no original callback)...');
                        try {
                            var fakeMultiboot = Module._malloc(16 * 4);
                            var heap = new Uint32Array(HEAPU8.buffer, fakeMultiboot, 16);
                            heap[0] = 0;
                            heap[1] = 0x800000;
                            console.log('[JS] Calling kernelMain...');
                            Module._kernelMain(fakeMultiboot, 0x2BADB002);
                            console.log('[JS] kernelMain returned');
                        } catch (e) {
                            console.error('[JS] Error starting kernel:', e);
                        }
                    }
                } else {
                    var status = document.getElementById('status');
                    if (status) {
                        status.textContent = 'Failed to initialize osakaOS. Check console for errors.';
                        status.classList.remove('hidden');
                        status.style.color = '#f00';
                    }
                }
            }
        }, 2000);
    </script>
</body>
</html>

